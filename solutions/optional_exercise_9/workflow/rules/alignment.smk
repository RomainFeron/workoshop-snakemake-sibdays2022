# Implement rules to align reads to an assembly and sort the resulting BAM files


def get_reads_file(wildcards):
    '''
    Input function to return the path to a reads file from the value of
    the wildcard 'sample'.
    '''
    return config['data']['samples'][wildcards.sample]


rule bwa_mem:
    '''
    Align any fastq reads file in 'data/sample' to the assembly 'data/genome.fa'.
    The process can be parallelized efficiently by increasing the number of threads.
    '''
    input:
        assembly = config['data']['assembly'],
        reads = get_reads_file
    output:
        'results/{sample}.bam'
    threads: config['bwa']['threads']
    log:
        'logs/bwa_mem_{sample}.txt'
    conda:
        # We created two environments here: one with the software to align reads
        # to the assembly and process BAM files, and one with the software to
        # call variants and run the Python script
        # Here, the path to the environment file is relative to the CURRENT FILE
        '../envs/alignment_env.yaml'
    shell:
        # Remember to add threads to the actual commands too!
        'bwa mem -t {threads} {input.assembly} {input.reads} 2> {log} | samtools view -b > {output} 2>> {log}'


rule samtools_sort:
    '''
    Sort a BAM file generated by the rule bwa_mem.
    We use the recommended syntax for dependencies between rules to specify the
    input: rules.<rule_name>.output. This syntax is preferred over 'results/{sample}.bam'
    because it will be automatically updated if we decide to change the output path of
    our first rule.
    '''
    input:
        rules.bwa_mem.output
    output:
        'results/{sample}.sorted.bam'
    log:
        'logs/samtools_sort_{sample}.txt'
    conda:
        # Here, the path to the environment file is relative to the CURRENT FILE
        '../envs/alignment_env.yaml'
    shell:
        'samtools sort -O bam {input} > {output} 2> {log}'
